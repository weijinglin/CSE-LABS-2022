#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include <list>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

// input core string and output core hash value
int string_hash(std::string str)
{
	unsigned res = 0;
	for(auto c : str){
		res += c - 'a';
	}

	return res % REDUCER_COUNT;
}

void split(string str, list<char> splits,vector<KeyVal>& res)
{
	istringstream iss(str);	// input stream
	string token;			// buffer
	while (getline(iss, token, splits.front()))
	{
        // ignore empty token
        if(token.size() == 0){
            continue;
        }

        list<char> reduce_split;
        auto iter = splits.begin();
        iter++;
        for(;iter != splits.end();){
            reduce_split.push_back(*iter);
            iter++;
        }

        if(reduce_split.size() != 0){
            split(token,reduce_split,res);
        } else {
            // the most inner call
            KeyVal pre_;
            pre_.key = token;
            pre_.val = "1";
            res.push_back(pre_);
        }
	}
}

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
	    std::vector<KeyVal> res;
    // split by the newline
    list<char> splits;
    splits.push_back('\n');
    splits.push_back(' ');
    splits.push_back(',');
    splits.push_back(':');
    splits.push_back('.');
    splits.push_back('?');
    splits.push_back('!');
    splits.push_back('-');
    splits.push_back('\"');
    splits.push_back('\'');
    splits.push_back(';');
    splits.push_back('(');
    splits.push_back(')');
    splits.push_back('*');
    splits.push_back('&');
    splits.push_back('|');
    for(int i = 0;i < 10;++i){
        splits.push_back(i + '0');
    }
    splits.push_back('#');
    splits.push_back('@');
    splits.push_back('[');
    splits.push_back(']');
    splits.push_back('{');
    splits.push_back('}');
    splits.push_back('_');
    split(content,splits,res);

    return res;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
	return std::to_string(values.size());
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const vector<string> &filenames);
	void doReduce(int index, int work_num);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const vector<string> &filenames)
{
	// Lab4: Your code goes here.
	// compute the immediate value and put in the core file
	// TODO(wjl) : here not need to add lock because each map work is independent 
	// first , read data from file and operate on it
	std::string input_file = filenames.at(index);

	std::string content;

	// Read the whole file into the buffer.
	getline(ifstream(input_file), content, '\0');

	vector <KeyVal> KVA = Map(input_file, content);

	// second , generate core file name
	int reduce_num = REDUCER_COUNT;
	std::vector<std::string> inter_file_vec;
	for(int i = 0;i < reduce_num;++i){
		inter_file_vec.push_back("mr-" + std::to_string(index) + "-" + std::to_string(i));
	}

	// build new empty file
	// ofstream new_file;
	// for(auto file : inter_file_vec){
	// 	new_file.open(file,ios::trunc);
	// 	new_file.close();
	// }

	// use simple hash function to decide which value put in which file
	// TODO(wjl) : do a opt , to put file in a time(in a traction) (hit on the performance)
	std::map<std::string,std::string> file_input;
	for(auto file : inter_file_vec){
		file_input.insert(std::pair<std::string,std::string>{file,""});
	}
	for(auto kv : KVA){
		int file_idx = string_hash(kv.key);
		// generate every file

		file_input[inter_file_vec.at(file_idx)] += kv.key + " " + kv.val + "\n";
	}

	// write to core file 
	for(auto file : inter_file_vec){
		// write one line each time
		ofstream out;
		out.open(file, ios::out|ios::binary|ios::trunc);
		out.write(file_input.at(file).c_str(),file_input.at(file).size());
		out.close();
	}
}

void Worker::doReduce(int index, int work_num)
{
	// Lab4: Your code goes here.
	// get all inter_file_name first
	printf("in reduce\n");
	std::vector<std::string> inter_file_vec;
	for(int i = 0;i < work_num;++i){
		inter_file_vec.push_back("mr-" + std::to_string(i) + "-" + std::to_string(index));
	}

	// inter key map
	std::map<std::string,std::vector<std::string>> inter_data;
	std::map<std::string,std::string> last_out;
	// call reduce for each inter_file
	for(auto file : inter_file_vec){
		// parse the data in a file
		// TODO(wjl) : other opt : read file in a time to reduce a IO in file system

		string content;

        // Read the whole file into the buffer.
        getline(ifstream(file), content, '\0');

		// split the string in the formal we want
		istringstream read_line(content);
		string line;
		while(getline(read_line, line, '\n'))
		{
			// the formal : key val \n
			istringstream iss(line);	// input stream
			string key_token,val_token;			// buffer
			// read key
			getline(iss,key_token,' ');
			if(inter_data.find(key_token) != inter_data.end()){
				getline(iss,val_token,' ');
				inter_data.at(key_token).push_back(val_token);
			} else {
				getline(iss,val_token,' ');
				inter_data.insert(std::pair<std::string,std::vector<std::string>>{key_token,{val_token}});
			}
		}
	}

	// sum up all out 
	for(auto kv : inter_data){
		std::string last_val = Reduce(kv.first,kv.second);
		last_out.insert(std::pair<std::string,std::string>{kv.first,last_val});
	}

	// write to file
	std::string file_out = "mr-out-" + std::to_string(index);

	// build a empty file
	ofstream new_file;
	new_file.open(file_out,ios::trunc);
	new_file.close();

	ofstream out;
	out.open(file_out, ios::out|ios::binary|ios::app);
	for(auto kv : last_out){
		out << kv.first + " " + kv.second + "\n";
	}
	out.close();

	printf("finish reduce\n");
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
	for (;;) {

		//
		// Lab4: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//

		// first , send rpc to ask for task
		int temp;
		mr_protocol::AskTaskResponse reply;
		this->cl->call(mr_protocol::asktask,temp,reply);
		
		switch (reply.type)
		{
		case mr_tasktype::MAP:
		{
			/* code */
			// do map work
			this->doMap(reply.file_index,reply.file_names);
			this->doSubmit(reply.type, reply.mem_idx);
			break;
		}
		case mr_tasktype::REDUCE:
		{
			/* code */
			// do reduce work
			printf("get reduce task\n");
			this->doReduce(reply.file_index, reply.file_names.size());
			this->doSubmit(reply.type, reply.mem_idx);
			break;
		}
		case mr_tasktype::NONE:
		{
			/* code */
			// this->doSubmit(reply.type, reply.mem_idx);
			// not job need to done , just sleep
			printf("get none task\n");
			
			/* code */
			// with not job needed , just sleep 3 seconds
			sleep(1);
			
			break;
		}
		
		default:
		{
			printf("what\n");
			break;
		}
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	printf("worker up\n");
	w.doWork();

	return 0;
}

